可以！下面这段代码会把 **A/B/C/main** 在“进入/挂起/恢复/结束”的时刻都打印出来，并且我还加了一个并发的 `D()`（心跳任务），让你能直观看到：**A 在 sleep 时，其他协程还能跑**。

把它复制运行（Python 3.8+，3.11 更好）：

```python
import asyncio
import time

t0 = time.perf_counter()

def log(msg: str):
    now = time.perf_counter() - t0
    task = asyncio.current_task()
    name = task.get_name() if task else "NoTask"
    print(f"{now:6.3f}s [{name:>6}] {msg}")

async def A():
    log("A: enter")
    log("A: await sleep(1) -> suspend A here")
    await asyncio.sleep(1)
    log("A: resumed after sleep")
    log("A: exit")

async def B():
    log("B: enter")
    log("B: await A() -> B will suspend until A completes")
    await A()
    log("B: resumed after A done")
    log("B: exit")

async def C():
    log("C: enter")
    log("C: await B() -> C will suspend until B completes")
    await B()
    log("C: resumed after B done")
    log("C: exit")

async def D():
    # 用来证明：A sleep 的时候，别的协程还能跑
    for i in range(6):
        log(f"D: heartbeat {i}")
        await asyncio.sleep(0.2)
    log("D: exit")

async def main():
    log("main: enter")
    log("main: await gather(C, D) -> main suspends until both finish")
    await asyncio.gather(
        asyncio.create_task(C(), name="Ctask"),
        asyncio.create_task(D(), name="Dtask"),
    )
    log("main: resumed after gather")
    log("main: exit")

if __name__ == "__main__":
    asyncio.run(asyncio.create_task(main(), name="MAIN"))
```

### 你运行后应该能看到的关键现象

* `B: await A()` 后，**B 不再输出**，直到 A 完成才“恢复”继续打印。
* `C: await B()` 同理。
* `main: await gather(...)` 后，main 也挂起等两个任务完成。
* 在 `A: await sleep(1)` 的 1 秒里，`D: heartbeat ...` 会持续输出，说明：

  * **暂停的是 A（以及等待 A 的 B/C/main 都处于等待挂起）**
  * **事件循环没停**，还能调度别的协程（这里就是 D）

如果你只想看你原来的“纯嵌套、无并发”版本，我也可以把 `D()` 和 `gather` 去掉，输出会更“干净”，但就看不到“别的协程还能跑”的效果了。你想要哪个版本更贴近你的实际场景？
