`asyncio.Task` 可以理解为：**把一个协程包装成“由事件循环调度的并发单元”**。

1. `Task` 是什么  
- 协程对象本身不会自动运行。  
- 只有被 `await`，或被包装成 `Task` 后，才会被事件循环执行。  
- `Task` 是 `Future` 的子类，可拿结果、异常、取消状态。

2. 怎么创建  
```python
task = asyncio.create_task(coro(), name="worker-1")
```
- 推荐 `create_task`（在当前 running loop 中）。  
- 旧写法 `loop.create_task(...)` 也可以。

3. 生命周期  
- `pending` -> `running` -> `done` 或 `cancelled`  
- 常用方法：`task.done()`、`task.cancel()`、`task.result()`、`task.exception()`

4. 并发执行的关键  
- 顺序写 `await a(); await b()` 是串行。  
- 并发要先建 task，再一起等：
```python
t1 = asyncio.create_task(a())
t2 = asyncio.create_task(b())
await t1
await t2
# 或 await asyncio.gather(t1, t2)
```

5. 取消（很重要）  
- `task.cancel()` 会向协程注入 `CancelledError`。  
- 协程里应在 `finally` 做清理资源。  
- 调用方通常要 `await task` 以让取消“落地”。

6. 错误处理  
- 不 `await` 的 task，异常可能变成 “Task exception was never retrieved”。  
- 最好统一收集：`gather` / `TaskGroup`。

7. 现代推荐（3.11+）  
- 用 `asyncio.TaskGroup()` 做结构化并发，错误传播和取消更安全。

一句话：**协程是“代码形态”，Task 是“调度实体”**。只有变成 Task（或被 await）才真正跑起来。