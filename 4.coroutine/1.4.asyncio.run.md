`asyncio.run`（不是 `async.run`）可以理解成“**一次性事件循环总管**”。

不是“只能用一次”，而是：

1. 可以在一个进程里调用多次（**串行**地）。
2. 不能在“当前线程已有运行中的事件循环”时再调用（**不能嵌套**）。

你看到的报错就是第 2 条。

**机制（执行流程）**
1. 检查参数是可等待对象（通常是顶层协程）。
2. 检查当前线程是否已有 running loop。  
有就报：`asyncio.run() cannot be called from a running event loop`。
3. 创建一个新的事件循环，并设为当前线程的 loop。
4. 把你的协程包装成 Task，`run_until_complete(...)` 跑到结束。
5. 结束清理：取消遗留任务、关闭异步生成器、关闭默认线程池执行器、关闭 loop。
6. 返回协程结果或抛出异常。

**所以建议**
1. 应用入口只写一次：`asyncio.run(main())`。
2. 在 `async def` 内部只用 `await` / `create_task` / `gather`，不要再 `asyncio.run(...)`。
3. 如果你在同步代码里确实要连续跑多个顶层协程，能多次 `asyncio.run(...)`，但通常不如一个 `main()` 统一管理清晰。

示例对比：

```python
# 推荐
async def main():
    await a()
    await b()

if __name__ == "__main__":
    asyncio.run(main())
```

```python
# 错误（在协程里再 run）
async def main():
    asyncio.run(a())  # 会报 nested loop 错误
```