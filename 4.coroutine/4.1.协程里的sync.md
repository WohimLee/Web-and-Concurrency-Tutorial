`asyncio.to_thread` 的作用是：**在协程里把一个阻塞的同步函数丢到线程里执行**，避免卡住事件循环。

```python
result = await asyncio.to_thread(func, *args, **kwargs)
```

关键点：

- 适用场景：同步阻塞 I/O（文件读写、老库的网络请求、`time.sleep`、阻塞 SDK）。
- 不适合：CPU 密集计算（受 GIL 影响），CPU 密集优先进程池。
- 行为：返回可等待对象，`await` 后拿到 `func` 返回值或异常。
- 线程来源：默认线程池（内部是 loop 的 executor）。
- 取消语义：取消 `await to_thread(...)` 只会取消等待；线程里已经跑起来的同步函数通常不会被“硬中断”。
- 上下文：会传播 `contextvars`（相比手写 `run_in_executor` 更方便）。
- 等价关系：它基本是 `run_in_executor` 的高层封装，写法更简洁。

示例：

```python
import asyncio
import time

def blocking_io():
    time.sleep(2)   # 阻塞调用
    return "done"

async def main():
    print("start")
    result = await asyncio.to_thread(blocking_io)
    print(result)

asyncio.run(main())
```

如果不想串行等它，也可以先 `create_task(asyncio.to_thread(...))`，再和其他协程一起 `gather`。


`asyncio.to_thread()` 本质上是：

```python
await loop.run_in_executor(None, func, *args)
```

所以结论很明确：

- 丢到的是**当前事件循环的默认 `ThreadPoolExecutor`**里的某个 worker 线程。
- 具体是哪个线程不固定，由线程池调度决定（可能复用同一个，也可能不同）。
- 不是新建“专属线程”每次跑一个。

你问“手动管理线程池”时：

- `to_thread` 本身不能传 `executor` 参数。
- 如果你先 `loop.set_default_executor(my_pool)`，那 `to_thread` 就会用你这个线程池。
- 如果你不设，就用 asyncio 懒创建的默认线程池。

如果你想每次明确指定某个线程池，用 `run_in_executor(custom_pool, ...)`。