## Intro
>👉 总结一句话
- 进程 = 独立运行的程序（隔离强、开销大）
- 线程 = 进程内的执行单元（共享内存、高并发）
- 协程 = 用户态轻量执行单元（高效、适合 I/O 密集）

### 1 进程（Process）
#### 1.1 进程
>定义
- 进程是操作系统 `分配资源（CPU 时间、内存空间、文件句柄等）的最小单位`。可以理解为正在运行的一个程序
>特点：
- 独立性强：不同进程之间相互独立，崩溃互不影响
- 资源开销大：每个进程都有独立的内存空间和系统资源，创建和切换开销大
- 通信方式复杂：进程间通信（IPC）需要借助操作系统机制，如管道、消息队列、共享内存、Socket 等
>适用场景
- 需要高可靠性、相互独立的任务，比如浏览器的每个标签页、数据库服务

>Example
- 进程
    - rag-orchestrator 进程：负责拆解用户问题、调用检索、调用重排、拼装提示词。
    - vector-search 进程：只提供相似度检索（Faiss/PGVector/Milvus）
    - rerank 进程：独立的 Cross-Encoder 重排服务
    - tool-exec 进程：专门跑浏览器/代码执行/数据库查询等危险或重依赖的工具
- 进程间通信（IPC）在 RAG 中
    - Orchestrator ↔ Vector 搜索：gRPC/HTTP
    - 触发长任务：消息队列（Kafka / RabbitMQ / Redis Streams）
    - 大块数据共享：共享存储/对象存储（S3）或内存型 KV（Redis）
    - 实时流式输出：WebSocket / Server-Sent Events

#### 1.2 进程池
>定义
- 进程池是提前创建好多个独立进程的池子，用于执行并行任务

>为什么要有它
- 在多核 CPU 下，进程之间可以真正并行（不受 Python GIL 限制）
- 每个进程有独立内存空间，避免线程那种共享数据导致的竞争问题
- 创建/销毁进程成本也很高，用池子可复用并受控

简单理解：
- 进程池 = 「多个独立车间」
- 每个车间有自己的设备（内存、CPU），任务调度器把工作分派过去干完再回收


### 2 线程（Thread）
#### 2.1 线程的概念
>定义
- 线程是操作系统`能够调度的最小执行单位`，是进程的子任务。一个进程可以包含多个线程，共享进程的资源
>特点
- 共享资源：同一进程中的线程共享内存和文件句柄等资源，通信方便
- 轻量级：相比进程，创建和切换成本更低
- 安全性差：因为共享内存，线程间容易产生竞争条件，需要加锁（Mutex、Semaphore）保证一致性，容易出现死锁
>适用场景
- 需要高并发、共享数据的场景，比如 Web 服务器的请求处理

#### 2.2 线程池

>定义
- 线程池是提前创建好一组可复用线程，由系统统一调度任务到这些线程中执行

>为什么要有它
- 创建和销毁线程的成本高（尤其是频繁请求的系统）
- 如果每来一个任务都创建新线程，系统会很快因为「线程爆炸」而崩溃（CPU 切换成本太高）
- 线程池统一管理、控制线程数量，避免资源耗尽

简单理解：
- 线程池 = 「一群工人」+「任务队列」
- 工人数量固定，任务来了就分配工人干，干完再回池里等下一个活。

### 3 协程（Coroutine）

>定义
- 协程是用户态的“轻量级线程”，由程序员或运行时库在应用层调度，而不是由操作系统内核调度
>特点
- 协作式调度：协程通过 `yield/await` 主动让出控制权，不依赖内核，切换开销极小
- 单线程内实现并发：避免多线程的锁竞争问题，但无法利用多核 CPU
- 易于编程：天然适合 I/O 密集型场景（等待网络、磁盘操作），因为协程在等待时可挂起，执行其他任务
>适用场景
- 高并发、I/O 密集型，比如爬虫、异步 Web 框架（如 Python 的 asyncio、Go 的 goroutine）


### 4 对比总结

| 特性       | 进程           | 线程                | 协程                |
| -------- | ------------ | ----------------- | ----------------- |
| **调度者**  | 操作系统内核       | 操作系统内核            | 用户程序              |
| **资源占用** | 高            | 中                 | 低                 |
| **切换开销** | 大（上下文切换要切内存） | 中（共享内存，但要保存寄存器状态） | 小（用户态，保存少量状态即可）   |
| **通信**   | IPC（复杂）      | 共享内存（需加锁）         | 共享内存（通常在单线程，无需加锁） |
| **并发能力** | 真并发（多核可并行）   | 真并发（多核可并行）        | 并发但非并行（单线程）       |
| **适合场景** | 高可靠性、隔离任务    | 计算密集型并发           | I/O 密集型并发         |

