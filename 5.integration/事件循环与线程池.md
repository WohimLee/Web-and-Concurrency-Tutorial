可以，分两层看。

1. 怎么知道“当前 loop 的默认线程池是哪个”
- `asyncio` 没有公开的 `get_default_executor()`。
- 最稳妥做法是：你自己 `set_default_executor(pool)` 并保留 `pool` 引用。
- 调试时可看私有属性 `loop._default_executor`（不保证未来版本稳定）。
- 还可以在线程函数里打印 `threading.current_thread().name/ident`，观察任务实际跑在哪个 worker 线程。

2. 每个事件循环/线程能有自己的 `ThreadPoolExecutor` 吗
- 能。**默认 executor 是“按事件循环”挂的**，不是全局唯一。
- 一个 loop 对应一个默认 executor 槽位；`to_thread()` / `run_in_executor(None, ...)` 用的就是这个槽位。
- 通常一个线程跑一个事件循环，所以看起来像“每个线程一个默认池”，但本质是“每个 loop 一个”。

补充：
- 未手动设置时，默认线程池会在首次用到时懒创建。
- `asyncio.run(...)` 结束时会帮你关闭该 loop 及其默认 executor。


不是“本质上只有一个线程池”，而是：

- 默认情况下：**每个事件循环有自己的默认 `ThreadPoolExecutor`**（独立对象、独立 worker 线程集合）。
- 只有你显式传同一个 `ThreadPoolExecutor`（`run_in_executor(pool, ...)`）时，才会共享同一个池。

分开每个 loop 的线程池，主要好处是：

1. 隔离性  
一个 loop 的阻塞任务不会把另一个 loop 的线程池挤满。

2. 生命周期清晰  
loop 结束时可以连同它的默认池一起关闭，资源回收更可控。

3. 配置可分域  
不同 loop 可设不同 `max_workers`、线程名前缀、用途策略。

4. 故障边界更小  
某个模块任务暴涨或异常时，影响范围局部化。

如果你的目标是全局统一限流，也可以故意共享一个自定义线程池；这是“手动集中管理”的设计，不是 asyncio 默认行为。