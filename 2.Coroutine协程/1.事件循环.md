## 事件循环 Event Loop

`asyncio` 的事件循环（Event Loop）本质上是一个“调度器 + I/O 监听器”。

### 1 它解决什么问题
- 在一个线程里管理很多并发任务。
- 遇到 I/O 等待时，不让线程空等，而是切去跑别的任务。
- 用“协作式切换”（`await`）替代线程抢占式切换。

### 2 核心工作机制
1. 维护“可运行任务队列”（ready queue）。
2. 维护“定时任务队列”（比如 `sleep`、超时）。
3. 监听 I/O 事件（socket 可读/可写等）。
4. 每一轮循环：
- 取可运行任务执行一小段。
- 任务遇到 `await` 挂起，注册恢复条件。
- 条件满足后把任务放回可运行队列。
- 重复直到没有任务或主任务结束。

### 3 关键点：`await` 才让出执行权
- 协程不会自动被打断。
- 只有到 `await` 点，当前协程才“主动交棒”。
- 所以协程里如果长时间不 `await`，会“卡住”整个循环。

### 4 事件循环和 Task 的关系
- 协程对象只是“可执行描述”。
- `Task` 是被事件循环调度的实体。
- 常见流程：
1. `asyncio.run(main())` 创建并启动循环。
2. `main` 里 `create_task(...)` 提交子任务。
3. 循环调度这些任务交替推进。
4. `main` 结束后关闭循环。

### 5 跟线程/进程的关系
- 一个线程通常同时只运行一个事件循环。
- 不同线程可以有不同事件循环。
- 事件循环是单线程并发，不是多核并行。
- CPU 密集任务要丢到线程池/进程池（`to_thread` / `run_in_executor`）。

### 6. 最小观察代码
```python
import asyncio, threading

async def worker(name):
    loop = asyncio.get_running_loop()
    print(name, "loop_id=", id(loop), "thread=", threading.get_ident())
    await asyncio.sleep(1)
    print(name, "done")

async def main():
    t1 = asyncio.create_task(worker("A"))
    t2 = asyncio.create_task(worker("B"))
    await asyncio.gather(t1, t2)

asyncio.run(main())
```
你会看到两个任务在同一个 `loop_id`、同一个线程里交替执行。

### 7. 常见坑
- 在协程里用 `time.sleep()`（会阻塞整个循环）。
- 忘记 `await`/不回收任务。
- 不处理取消（`CancelledError`）。
- 一次性创建过多任务，不做限流。

如果你愿意，我可以基于你当前 `1.Coroutine协程/src/1.1.event_loop_demo.py` 直接加“可视化日志版”，让你看到每次切换是在哪里发生的。