用“概念 -> 小实验 -> 真实场景 -> 工程化”四层来学，效率最高。

**学习路线（4周）**
1. 第1周：打底模型  
- 学 `event loop`、`coroutine`、`Task`、`await` 的关系。  
- 只练 3 个 API：`asyncio.run`、`create_task`、`await`。  
- 目标：能解释“为什么 `await` 才会让出执行权”。

2. 第2周：并发控制  
- 学 `gather`、`wait_for`、`timeout`、`Queue`、`Semaphore`、`Lock`。  
- 重点：限流、超时、取消（`CancelledError`）。  
- 目标：能写“100 个任务并发，但最多 10 个同时执行”。

3. 第3周：I/O 实战  
- 做 2 个场景：批量 HTTP 请求、生产者-消费者流水线。  
- 加入重试、超时、背压（队列上限）。  
- 目标：把同步脚本改成 asyncio 版本并测耗时对比。

4. 第4周：工程化  
- 学任务生命周期管理、优雅退出、日志与调试。  
- 补测试：`pytest + pytest-asyncio`。  
- 目标：写一个可长期维护的异步服务骨架。


**每次学习的固定模板**
1. 先画调用时序（谁创建 Task，谁 await）。  
2. 写最小可运行例子（20-40 行）。  
3. 人为制造异常（超时、取消、连接失败）。  
4. 记录“现象-原因-修复方式”。

**最常见误区**
- 把 CPU 密集任务硬塞 asyncio（应改多进程/线程池）。  
- 忘记处理取消和超时。  
- 无限制 `create_task` 导致资源打爆。  
- 以为“用了 async 就一定更快”。

